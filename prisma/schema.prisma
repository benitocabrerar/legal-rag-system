generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums for Legal Documents
enum NormType {
  CONSTITUTIONAL_NORM
  ORGANIC_LAW
  ORDINARY_LAW
  ORGANIC_CODE
  ORDINARY_CODE
  REGULATION_GENERAL
  REGULATION_EXECUTIVE
  ORDINANCE_MUNICIPAL
  ORDINANCE_METROPOLITAN
  RESOLUTION_ADMINISTRATIVE
  RESOLUTION_JUDICIAL
  ADMINISTRATIVE_AGREEMENT
  INTERNATIONAL_TREATY
  JUDICIAL_PRECEDENT
}

enum LegalHierarchy {
  CONSTITUCION
  TRATADOS_INTERNACIONALES_DDHH
  LEYES_ORGANICAS
  LEYES_ORDINARIAS
  CODIGOS_ORGANICOS
  CODIGOS_ORDINARIOS
  REGLAMENTOS
  ORDENANZAS
  RESOLUCIONES
  ACUERDOS_ADMINISTRATIVOS
}

enum PublicationType {
  ORDINARIO
  SUPLEMENTO
  SEGUNDO_SUPLEMENTO
  SUPLEMENTO_ESPECIAL
  EDICION_CONSTITUCIONAL
}

enum DocumentState {
  ORIGINAL
  REFORMADO
}

enum Jurisdiction {
  NACIONAL
  PROVINCIAL
  MUNICIPAL
  INTERNACIONAL
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String?
  passwordHash  String?   @map("password_hash")
  role          String    @default("user")
  planTier      String    @default("free") @map("plan_tier")
  isActive      Boolean   @default(true) @map("is_active")
  lastLogin     DateTime? @map("last_login")
  storageUsedMB Float     @default(0) @map("storage_used_mb")
  totalQueries  Int       @default(0) @map("total_queries")
  avatarUrl     String?   @map("avatar_url")
  phoneNumber   String?   @map("phone_number")
  address       String?
  city          String?
  country       String?   @default("Ecuador")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // OAuth Authentication
  provider String  @default("local")
  googleId String? @unique @map("google_id")

  // Two-Factor Authentication
  twoFactorEnabled     Boolean   @default(false) @map("two_factor_enabled")
  twoFactorSecret      String?   @map("two_factor_secret")
  twoFactorBackupCodes String[]  @map("two_factor_backup_codes")
  twoFactorVerifiedAt  DateTime? @map("two_factor_verified_at")

  // Professional Details
  barNumber      String? @map("bar_number")
  lawFirm        String? @map("law_firm")
  specialization String?
  licenseState   String? @map("license_state")
  bio            String? @db.Text

  // User Preferences
  language           String?  @map("language")
  timezone           String?  @map("timezone")
  theme              String?  @map("theme")
  emailNotifications Boolean? @map("email_notifications")
  marketingEmails    Boolean? @map("marketing_emails")

  cases                 Case[]
  documents             Document[]
  legalDocuments        LegalDocument[]
  quota                 UserQuota?
  apiKeys               ApiKey[]
  notifications         Notification[]
  auditLogs             AuditLog[]
  queryLogs             QueryLog[]
  storageUsage          StorageUsage[]
  subscriptions         Subscription[]
  payments              Payment[]
  paymentProofs         PaymentProof[]
  reviewedPaymentProofs PaymentProof[]  @relation("ReviewedPaymentProofs")
  settings              UserSettings?
  usageHistory          UsageHistory[]

  // New relations for Calendar, Tasks, and Notifications modules
  createdEvents         Event[]         @relation("CreatedEvents")
  eventParticipations   EventParticipant[]
  eventReminders        EventReminder[]
  assignedTasks         Task[]          @relation("AssignedTasks")
  createdTasks          Task[]          @relation("CreatedTasks")
  completedChecklistItems TaskChecklistItem[]
  taskHistory           TaskHistory[]
  notificationLogs      NotificationLog[]

  // Document Analysis System relations
  createdAnalysisJobs   AnalysisQueue[]
  notificationSubscriptions NotificationSubscription[] @relation("NotificationSubscriptions")
  notificationQueueRecipient NotificationQueue[]      @relation("NotificationQueueRecipient")

  // Phase 7: User Feedback Loop relations
  searchInteractions    SearchInteraction[]  @relation("SearchInteractions")
  abTestAssignments     ABTestAssignment[]   @relation("UserABTestAssignments")

  // Phase 9: Advanced Search & User Experience relations
  savedSearches         SavedSearch[]        @relation("UserSavedSearches")
  documentCollections   DocumentCollection[] @relation("UserCollections")
  sharedSearchLinks     SharedSearchLink[]   @relation("UserSharedLinks")

  // Phase 10: AI & Analytics relations
  aiConversations       AIConversation[]     @relation("UserAIConversations")
  analyticsEvents       AnalyticsEvent[]     @relation("UserAnalyticsEvents")

  // Phase 10 Week 3: NLP-RAG Integration relations
  queryHistory          QueryHistory[]       @relation("UserQueryHistory")
  userSessions          UserSession[]        @relation("UserSessions")

  @@map("users")
}

model Case {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  title       String
  description String?
  clientName  String?  @map("client_name")
  caseNumber  String?  @map("case_number")
  status      String   @default("active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  documents Document[]

  // New relations for Calendar, Tasks, and Finance modules
  events          Event[]
  tasks           Task[]
  agreements      Agreement[]
  serviceItems    ServiceItem[]
  invoices        InvoiceFinance[]
  payments        PaymentFinance[]
  finance         CaseFinance?

  @@map("cases")
}

model Document {
  id        String   @id @default(uuid())
  caseId    String   @map("case_id")
  userId    String   @map("user_id")
  title     String
  content   String   @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  case   Case            @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  chunks DocumentChunk[]

  @@map("documents")
}

model DocumentChunk {
  id         String   @id @default(uuid())
  documentId String   @map("document_id")
  content    String   @db.Text
  chunkIndex Int      @map("chunk_index")
  embedding  Json?
  createdAt  DateTime @default(now()) @map("created_at")

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@map("document_chunks")
}

model LegalDocument {
  id            String   @id @default(uuid())

  // New required fields according to specifications
  normType             NormType          @map("norm_type")                    // Tipo de Norma (replaces old title field)
  normTitle            String            @map("norm_title")                   // Título de la Norma (actual document title)
  legalHierarchy       LegalHierarchy    @map("legal_hierarchy")              // Jerarquía Legal (replaces old category)
  publicationType      PublicationType   @map("publication_type")             // Tipo de Publicación Registro Oficial
  publicationNumber    String            @map("publication_number")           // Número de Publicación Registro Oficial
  publicationDate      DateTime?         @map("publication_date")             // Fecha de Publicación
  lastReformDate       DateTime?         @map("last_reform_date")             // Fecha de última reforma
  documentState        DocumentState     @default(ORIGINAL) @map("document_state") // Estado: Original/Reformado
  jurisdiction         Jurisdiction      @default(NACIONAL)                   // Jurisdicción

  // Content and processing
  content              String            @db.Text                             // Full document text content
  metadata             Json?                                                   // Additional metadata

  // Legacy fields (kept for backward compatibility)
  title                String?                                                 // Old title field (deprecated, use normTitle)
  category             String?                                                 // Old category (deprecated, use legalHierarchy)

  // Admin and tracking
  uploadedBy           String            @map("uploaded_by")
  isActive             Boolean           @default(true) @map("is_active")
  viewCount            Int               @default(0) @map("view_count")
  downloadCount        Int               @default(0) @map("download_count")
  createdAt            DateTime          @default(now()) @map("created_at")
  updatedAt            DateTime          @updatedAt @map("updated_at")

  // Relations
  uploader             User              @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)
  chunks               LegalDocumentChunk[]
  specialties          DocumentSpecialty[]

  // Document Analysis System relations
  articles             LegalDocumentArticle[]
  sections             LegalDocumentSection[]
  summaries            LegalDocumentSummary[]

  // Phase 7: User Feedback Loop relations
  clickEvents          ClickEvent[]          @relation("DocumentClickEvents")
  relevanceFeedback    RelevanceFeedback[]   @relation("DocumentRelevanceFeedback")

  // Phase 8: Cross-Reference Graph relations
  sourceCitations      DocumentCitation[]    @relation("SourceCitations")
  targetCitations      DocumentCitation[]    @relation("TargetCitations")
  sourceRelationships  DocumentRelationship[] @relation("SourceRelationships")
  targetRelationships  DocumentRelationship[] @relation("TargetRelationships")
  authorityScore       DocumentAuthorityScore?
  citationJobs         CitationExtractionJob[]

  // Phase 9: Advanced Search & User Experience relations
  collectionDocuments         CollectionDocument[]      @relation("DocumentInCollections")
  sourceRecommendations       DocumentRecommendation[]  @relation("SourceRecommendations")
  recommendedInDocuments      DocumentRecommendation[]  @relation("RecommendedDocuments")

  // Phase 10: AI & Analytics relations
  aiCitations                 AICitation[]              @relation("AIDocumentCitations")
  documentAnalytics           DocumentAnalytics[]       @relation("DocumentAnalytics")
  documentSummaries           DocumentSummary[]         @relation("DocumentSummaries")
  articleAnalysis             ArticleAnalysis[]         @relation("DocumentArticleAnalysis")

  @@index([normType])
  @@index([legalHierarchy])
  @@index([jurisdiction])
  @@index([publicationType])
  @@index([documentState])
  @@index([publicationDate])
  @@map("legal_documents")
}

model LegalDocumentChunk {
  id              String   @id @default(uuid())
  legalDocumentId String   @map("legal_document_id")
  content         String   @db.Text
  chunkIndex      Int      @map("chunk_index")
  embedding       Json?
  createdAt       DateTime @default(now()) @map("created_at")

  legalDocument LegalDocument @relation(fields: [legalDocumentId], references: [id], onDelete: Cascade)

  @@index([legalDocumentId])
  @@map("legal_document_chunks")
}

// Legal Specialties - Hierarchical structure for legal areas
model LegalSpecialty {
  id           String   @id @default(uuid())
  code         String   @unique
  name         String
  nameEnglish  String?  @map("name_english")
  description  String?  @db.Text
  parentId     String?  @map("parent_id")
  level        Int      @default(1)
  displayOrder Int      @default(0) @map("display_order")
  isActive     Boolean  @default(true) @map("is_active")
  icon         String?
  color        String?
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  parent    LegalSpecialty?     @relation("SpecialtyHierarchy", fields: [parentId], references: [id])
  children  LegalSpecialty[]    @relation("SpecialtyHierarchy")
  documents DocumentSpecialty[]

  @@index([parentId])
  @@index([code])
  @@map("legal_specialties")
}

// Join table for LegalDocument and LegalSpecialty (many-to-many)
model DocumentSpecialty {
  id          String   @id @default(uuid())
  documentId  String   @map("document_id")
  specialtyId String   @map("specialty_id")
  isPrimary   Boolean  @default(false) @map("is_primary")
  createdAt   DateTime @default(now()) @map("created_at")

  document  LegalDocument  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  specialty LegalSpecialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  @@unique([documentId, specialtyId])
  @@index([documentId])
  @@index([specialtyId])
  @@map("document_specialties")
}

// Audit Log - Tracks all admin actions
model AuditLog {
  id           String   @id @default(uuid())
  userId       String?  @map("user_id")
  action       String
  entity       String
  entityId     String?  @map("entity_id")
  changes      Json?
  ipAddress    String?  @map("ip_address")
  userAgent    String?  @map("user_agent")
  success      Boolean  @default(true)
  errorMessage String?  @map("error_message")
  createdAt    DateTime @default(now()) @map("created_at")

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([entity])
  @@index([createdAt])
  @@map("audit_logs")
}

// Query Log - Tracks RAG queries for analytics
model QueryLog {
  id             String   @id @default(uuid())
  userId         String?  @map("user_id")
  query          String   @db.Text
  response       String?  @db.Text
  documentsFound Int      @default(0) @map("documents_found")
  responseTime   Int      @map("response_time")
  tokensUsed     Int      @default(0) @map("tokens_used")
  model          String?
  success        Boolean  @default(true)
  errorMessage   String?  @map("error_message")
  ipAddress      String?  @map("ip_address")
  createdAt      DateTime @default(now()) @map("created_at")

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([createdAt])
  @@map("query_logs")
}

// User Quota - Storage and usage limits per user
model UserQuota {
  id               String   @id @default(uuid())
  userId           String   @unique @map("user_id")
  storageGB        Float    @default(5.0) @map("storage_gb")
  storageUsedGB    Float    @default(0.0) @map("storage_used_gb")
  documentsLimit   Int      @default(100) @map("documents_limit")
  documentsUsed    Int      @default(0) @map("documents_used")
  monthlyQueries   Int      @default(1000) @map("monthly_queries")
  queriesUsedMonth Int      @default(0) @map("queries_used_month")
  apiCallsLimit    Int      @default(10000) @map("api_calls_limit")
  apiCallsUsed     Int      @default(0) @map("api_calls_used")
  resetDate        DateTime @map("reset_date")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_quotas")
}

// Storage Usage - Detailed storage tracking per user
model StorageUsage {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  category       String
  sizeMB         Float    @map("size_mb")
  fileCount      Int      @default(0) @map("file_count")
  lastCalculated DateTime @default(now()) @map("last_calculated")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([category])
  @@map("storage_usage")
}

// System Metrics - Platform-wide statistics
model SystemMetric {
  id          String   @id @default(uuid())
  metricName  String   @map("metric_name")
  metricValue Float    @map("metric_value")
  metricUnit  String?  @map("metric_unit")
  category    String
  timestamp   DateTime @default(now())
  metadata    Json?

  @@index([metricName])
  @@index([category])
  @@index([timestamp])
  @@map("system_metrics")
}

// Database Stats - PostgreSQL database statistics
model DatabaseStats {
  id          String    @id @default(uuid())
  tableName   String    @map("table_name")
  rowCount    Int       @map("row_count")
  sizeMB      Float     @map("size_mb")
  indexSizeMB Float     @default(0) @map("index_size_mb")
  lastVacuum  DateTime? @map("last_vacuum")
  lastAnalyze DateTime? @map("last_analyze")
  timestamp   DateTime  @default(now())

  @@index([tableName])
  @@index([timestamp])
  @@map("database_stats")
}

// API Keys - For programmatic access
model ApiKey {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  name        String
  keyHash     String    @unique @map("key_hash")
  lastUsed    DateTime? @map("last_used")
  expiresAt   DateTime? @map("expires_at")
  isActive    Boolean   @default(true) @map("is_active")
  permissions Json?
  usageCount  Int       @default(0) @map("usage_count")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([keyHash])
  @@map("api_keys")
}

// Notifications - System notifications for users
model Notification {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  type      String
  title     String
  message   String    @db.Text
  priority  String    @default("normal")
  isRead    Boolean   @default(false) @map("is_read")
  readAt    DateTime? @map("read_at")
  actionUrl String?   @map("action_url")
  metadata  Json?
  createdAt DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

// Subscription Plans - Available pricing tiers
model SubscriptionPlan {
  id              String   @id @default(uuid())
  code            String   @unique
  name            String
  nameEnglish     String   @map("name_english")
  description     String?  @db.Text
  priceMonthlyUSD Float    @map("price_monthly_usd")
  priceYearlyUSD  Float    @map("price_yearly_usd")
  storageGB       Float    @map("storage_gb")
  documentsLimit  Int      @map("documents_limit")
  monthlyQueries  Int      @map("monthly_queries")
  apiCallsLimit   Int      @map("api_calls_limit")
  features        Json?
  isActive        Boolean  @default(true) @map("is_active")
  displayOrder    Int      @default(0) @map("display_order")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  subscriptions Subscription[]

  @@map("subscription_plans")
}

// User Subscriptions - Active user subscriptions
model Subscription {
  id                   String    @id @default(uuid())
  userId               String    @map("user_id")
  planId               String    @map("plan_id")
  status               String    @default("pending") // pending, active, suspended, cancelled, expired
  billingCycle         String    @default("monthly") @map("billing_cycle") // monthly, yearly
  currentPeriodStart   DateTime  @map("current_period_start")
  currentPeriodEnd     DateTime  @map("current_period_end")
  cancelAtPeriodEnd    Boolean   @default(false) @map("cancel_at_period_end")
  cancelledAt          DateTime? @map("cancelled_at")
  stripeSubscriptionId String?   @unique @map("stripe_subscription_id")
  stripeCustomerId     String?   @map("stripe_customer_id")
  paypalSubscriptionId String?   @unique @map("paypal_subscription_id")
  metadata             Json?
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")

  user     User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan     SubscriptionPlan @relation(fields: [planId], references: [id])
  payments Payment[]

  @@index([userId])
  @@index([status])
  @@map("subscriptions")
}

// Payments - All payment transactions
model Payment {
  id             String    @id @default(uuid())
  subscriptionId String?   @map("subscription_id")
  userId         String    @map("user_id")
  amount         Float
  currency       String    @default("USD")
  method         String // stripe, paypal, bank_transfer, cash_deposit
  status         String    @default("pending") // pending, processing, completed, failed, refunded
  externalId     String?   @map("external_id") // Stripe/PayPal transaction ID
  description    String?
  metadata       Json?
  processingFee  Float?    @map("processing_fee")
  netAmount      Float?    @map("net_amount")
  paidAt         DateTime? @map("paid_at")
  failedAt       DateTime? @map("failed_at")
  refundedAt     DateTime? @map("refunded_at")
  errorMessage   String?   @map("error_message")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  subscription Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  paymentProof PaymentProof?

  @@index([userId])
  @@index([status])
  @@index([method])
  @@index([createdAt])
  @@map("payments")
}

// Payment Proofs - Manual payment verification (bank transfers, deposits)
model PaymentProof {
  id              String    @id @default(uuid())
  paymentId       String    @unique @map("payment_id")
  userId          String    @map("user_id")
  fileUrl         String    @map("file_url")
  fileName        String    @map("file_name")
  fileSize        Int       @map("file_size")
  mimeType        String    @map("mime_type")
  bankName        String?   @map("bank_name")
  accountNumber   String?   @map("account_number")
  referenceNumber String?   @map("reference_number")
  depositDate     DateTime? @map("deposit_date")
  notes           String?   @db.Text
  status          String    @default("pending") // pending, approved, rejected
  reviewedBy      String?   @map("reviewed_by")
  reviewedAt      DateTime? @map("reviewed_at")
  reviewNotes     String?   @map("review_notes") @db.Text
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  payment  Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer User?   @relation("ReviewedPaymentProofs", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("payment_proofs")
}

// User Settings - Comprehensive user preferences
model UserSettings {
  id     String @id @default(uuid())
  userId String @unique @map("user_id")

  // General Settings
  language   String @default("es")
  timezone   String @default("America/Guayaquil")
  dateFormat String @default("DD/MM/YYYY") @map("date_format")
  timeFormat String @default("24h") @map("time_format")
  theme      String @default("light")

  // Notification Preferences
  emailNotifications Boolean @default(true) @map("email_notifications")
  pushNotifications  Boolean @default(true) @map("push_notifications")
  smsNotifications   Boolean @default(false) @map("sms_notifications")
  marketingEmails    Boolean @default(false) @map("marketing_emails")
  weeklyDigest       Boolean @default(true) @map("weekly_digest")
  caseUpdates        Boolean @default(true) @map("case_updates")
  documentAlerts     Boolean @default(true) @map("document_alerts")
  billingAlerts      Boolean @default(true) @map("billing_alerts")

  // Privacy Settings
  profileVisibility String  @default("private") @map("profile_visibility")
  showEmail         Boolean @default(false) @map("show_email")
  showPhone         Boolean @default(false) @map("show_phone")
  allowDataExport   Boolean @default(true) @map("allow_data_export")

  // Integration Settings
  slackWebhook String? @map("slack_webhook")
  teamsWebhook String? @map("teams_webhook")
  zapierApiKey String? @map("zapier_api_key")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

// Usage History - Detailed usage tracking over time
model UsageHistory {
  id     String @id @default(uuid())
  userId String @map("user_id")

  // Date tracking
  date  DateTime
  year  Int
  month Int
  week  Int

  // Usage metrics
  aiQueriesCount    Int   @default(0) @map("ai_queries_count")
  documentsUploaded Int   @default(0) @map("documents_uploaded")
  casesCreated      Int   @default(0) @map("cases_created")
  storageUsedMB     Float @default(0) @map("storage_used_mb")
  apiCallsCount     Int   @default(0) @map("api_calls_count")

  // Advanced metrics
  averageResponseTimeMs Int? @map("average_response_time_ms")
  totalTokensUsed       Int  @default(0) @map("total_tokens_used")
  documentsAnalyzed     Int  @default(0) @map("documents_analyzed")
  searchesPerformed     Int  @default(0) @map("searches_performed")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
  @@index([year, month])
  @@map("usage_history")
}

// Invoice model for billing history
model Invoice {
  id             String  @id @default(uuid())
  userId         String  @map("user_id")
  subscriptionId String? @map("subscription_id")

  invoiceNumber String @unique @map("invoice_number")
  amount        Float
  currency      String @default("USD")
  status        String @default("pending") // pending, paid, failed, refunded

  // Invoice details
  periodStart DateTime  @map("period_start")
  periodEnd   DateTime  @map("period_end")
  dueDate     DateTime  @map("due_date")
  paidAt      DateTime? @map("paid_at")

  // Line items
  items Json

  // Tax information
  subtotal  Float
  taxAmount Float @default(0) @map("tax_amount")
  taxRate   Float @default(0) @map("tax_rate")
  total     Float

  // Payment info
  paymentMethod String? @map("payment_method")
  paymentId     String? @map("payment_id")

  // Documents
  pdfUrl String? @map("pdf_url")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@index([status])
  @@index([invoiceNumber])
  @@map("invoices")
}

// Payment Methods - Stored payment methods
model PaymentMethod {
  id     String @id @default(uuid())
  userId String @map("user_id")

  type      String // card, bank_account, paypal
  isDefault Boolean @default(false) @map("is_default")

  // Card details (encrypted/tokenized)
  cardLast4    String? @map("card_last4")
  cardBrand    String? @map("card_brand")
  cardExpMonth Int?    @map("card_exp_month")
  cardExpYear  Int?    @map("card_exp_year")

  // Bank account details
  bankName     String? @map("bank_name")
  accountLast4 String? @map("account_last4")

  // PayPal details
  paypalEmail String? @map("paypal_email")

  // External IDs
  stripePaymentMethodId String? @unique @map("stripe_payment_method_id")
  paypalBillingId       String? @unique @map("paypal_billing_id")

  isActive Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("payment_methods")
}

// ============================================================================
// CALENDAR & EVENTS MODULE
// ============================================================================

enum EventType {
  HEARING
  MEETING
  DEADLINE
  CONSULTATION
  COURT_DATE
  FILING_DEADLINE
  CLIENT_MEETING
  INTERNAL_MEETING
  PHONE_CALL
  VIDEO_CONFERENCE
  OTHER
}

enum EventStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  RESCHEDULED
  NO_SHOW
}

enum ReminderType {
  EMAIL
  SMS
  IN_APP
  PUSH
}

model Event {
  id              String        @id @default(uuid())
  title           String
  description     String?       @db.Text
  type            EventType
  status          EventStatus   @default(SCHEDULED)
  location        String?
  meetingLink     String?       @map("meeting_link")
  startTime       DateTime      @map("start_time")
  endTime         DateTime      @map("end_time")
  allDay          Boolean       @default(false) @map("all_day")
  timezone        String        @default("America/Guayaquil")

  // Recurring events
  isRecurring     Boolean       @default(false) @map("is_recurring")
  recurrenceRule  String?       @map("recurrence_rule") // iCalendar RRULE format
  recurrenceEnd   DateTime?     @map("recurrence_end")
  parentEventId   String?       @map("parent_event_id")

  // Associations
  caseId          String?       @map("case_id")
  createdBy       String        @map("created_by")

  // Metadata
  color           String?       // For calendar display
  isPrivate       Boolean       @default(false) @map("is_private")
  notes           String?       @db.Text
  attachments     Json?         // File references

  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  case            Case?         @relation(fields: [caseId], references: [id], onDelete: Cascade)
  creator         User          @relation("CreatedEvents", fields: [createdBy], references: [id], onDelete: Cascade)
  parentEvent     Event?        @relation("RecurringEvents", fields: [parentEventId], references: [id])
  recurringEvents Event[]       @relation("RecurringEvents")
  participants    EventParticipant[]
  reminders       EventReminder[]

  @@index([caseId])
  @@index([createdBy])
  @@index([startTime])
  @@index([status])
  @@index([type])
  @@map("events")
}

model EventParticipant {
  id              String   @id @default(uuid())
  eventId         String   @map("event_id")
  userId          String?  @map("user_id")
  email           String?  // For external participants
  name            String?  // For external participants
  role            String   @default("attendee") // organizer, attendee, optional
  status          String   @default("pending") // pending, accepted, declined, tentative
  responseTime    DateTime? @map("response_time")
  notes           String?  @db.Text
  createdAt       DateTime @default(now()) @map("created_at")

  event           Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@unique([eventId, email])
  @@index([eventId])
  @@index([userId])
  @@map("event_participants")
}

model EventReminder {
  id              String       @id @default(uuid())
  eventId         String       @map("event_id")
  type            ReminderType
  minutesBefore   Int          @map("minutes_before")
  sentAt          DateTime?    @map("sent_at")
  status          String       @default("pending") // pending, sent, failed
  recipientUserId String?      @map("recipient_user_id")
  recipientEmail  String?      @map("recipient_email")
  errorMessage    String?      @map("error_message")
  createdAt       DateTime     @default(now()) @map("created_at")

  event           Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  recipient       User?        @relation(fields: [recipientUserId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([sentAt])
  @@index([status])
  @@map("event_reminders")
}

// ============================================================================
// TASKS MODULE
// ============================================================================

enum TaskStatus {
  TODO
  IN_PROGRESS
  BLOCKED
  REVIEW
  COMPLETED
  CANCELLED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model Task {
  id              String        @id @default(uuid())
  title           String
  description     String?       @db.Text
  status          TaskStatus    @default(TODO)
  priority        TaskPriority  @default(MEDIUM)

  // Associations
  caseId          String?       @map("case_id")
  assignedTo      String?       @map("assigned_to")
  createdBy       String        @map("created_by")

  // Dates
  dueDate         DateTime?     @map("due_date")
  startDate       DateTime?     @map("start_date")
  completedAt     DateTime?     @map("completed_at")

  // Progress tracking
  estimatedHours  Float?        @map("estimated_hours")
  actualHours     Float?        @map("actual_hours")
  progress        Int           @default(0) // 0-100 percentage

  // Metadata
  tags            String[]
  isRecurring     Boolean       @default(false) @map("is_recurring")
  recurrenceRule  String?       @map("recurrence_rule")
  parentTaskId    String?       @map("parent_task_id")
  dependsOn       String[]      @map("depends_on") // Array of task IDs
  attachments     Json?

  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  case            Case?         @relation(fields: [caseId], references: [id], onDelete: Cascade)
  assignee        User?         @relation("AssignedTasks", fields: [assignedTo], references: [id], onDelete: SetNull)
  creator         User          @relation("CreatedTasks", fields: [createdBy], references: [id], onDelete: Cascade)
  parentTask      Task?         @relation("SubTasks", fields: [parentTaskId], references: [id])
  subTasks        Task[]        @relation("SubTasks")
  checklistItems  TaskChecklistItem[]
  history         TaskHistory[]

  @@index([caseId])
  @@index([assignedTo])
  @@index([createdBy])
  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@map("tasks")
}

model TaskChecklistItem {
  id              String   @id @default(uuid())
  taskId          String   @map("task_id")
  title           String
  isCompleted     Boolean  @default(false) @map("is_completed")
  completedAt     DateTime? @map("completed_at")
  completedBy     String?  @map("completed_by")
  displayOrder    Int      @default(0) @map("display_order")
  createdAt       DateTime @default(now()) @map("created_at")

  task            Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  completedByUser User?    @relation(fields: [completedBy], references: [id], onDelete: SetNull)

  @@index([taskId])
  @@map("task_checklist_items")
}

model TaskHistory {
  id              String   @id @default(uuid())
  taskId          String   @map("task_id")
  userId          String   @map("user_id")
  action          String   // created, updated, status_changed, assigned, completed, etc.
  changes         Json?    // Before/after values
  comment         String?  @db.Text
  timestamp       DateTime @default(now())

  task            Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([taskId])
  @@index([userId])
  @@index([timestamp])
  @@map("task_history")
}

// ============================================================================
// NOTIFICATIONS MODULE (Enhanced)
// ============================================================================

enum NotificationChannel {
  IN_APP
  EMAIL
  SMS
  PUSH
}

model NotificationTemplate {
  id              String   @id @default(uuid())
  name            String
  code            String   @unique
  channel         NotificationChannel
  subject         String?
  bodyTemplate    String   @db.Text @map("body_template")
  variables       Json?    // Available template variables
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  logs            NotificationLog[]
  queues          NotificationQueue[] @relation("NotificationQueueTemplate")

  @@map("notification_templates")
}

model NotificationLog {
  id              String               @id @default(uuid())
  templateId      String?              @map("template_id")
  userId          String?              @map("user_id")
  channel         NotificationChannel
  recipient       String               // Email, phone number, or user ID
  subject         String?
  body            String               @db.Text
  status          String               @default("pending") // pending, sent, failed, bounced
  sentAt          DateTime?            @map("sent_at")
  deliveredAt     DateTime?            @map("delivered_at")
  readAt          DateTime?            @map("read_at")
  errorMessage    String?              @map("error_message")
  metadata        Json?
  createdAt       DateTime             @default(now()) @map("created_at")

  template        NotificationTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  user            User?                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([channel])
  @@index([createdAt])
  @@map("notification_logs")
}

// ============================================================================
// FINANCE MODULE
// ============================================================================

enum PaymentStatus {
  PENDING
  PAID
  PARTIAL
  OVERDUE
  CANCELLED
  REFUNDED
}

enum PaymentMethodType {
  CASH
  BANK_TRANSFER
  CREDIT_CARD
  DEBIT_CARD
  CHECK
  PAYPAL
  STRIPE
  OTHER
}

enum InvoiceStatus {
  DRAFT
  SENT
  VIEWED
  PAID
  PARTIAL
  OVERDUE
  CANCELLED
  REFUNDED
}

enum ServiceItemType {
  CONSULTATION
  COURT_REPRESENTATION
  DOCUMENT_PREPARATION
  RESEARCH
  FILING
  NEGOTIATION
  HOURLY_WORK
  FIXED_FEE
  EXPENSE
  OTHER
}

model Agreement {
  id              String   @id @default(uuid())
  caseId          String   @map("case_id")
  title           String
  description     String?  @db.Text

  // Financial terms
  totalAmount     Float    @map("total_amount")
  currency        String   @default("USD")
  paymentTerms    String?  @db.Text @map("payment_terms")

  // Dates
  startDate       DateTime @map("start_date")
  endDate         DateTime? @map("end_date")
  signedDate      DateTime? @map("signed_date")

  // Status
  status          String   @default("draft") // draft, active, completed, terminated
  isActive        Boolean  @default(true) @map("is_active")

  // Documents
  documentUrl     String?  @map("document_url")
  signatureUrl    String?  @map("signature_url")

  // Metadata
  notes           String?  @db.Text
  metadata        Json?

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  case            Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  serviceItems    ServiceItem[]

  @@index([caseId])
  @@index([status])
  @@map("agreements")
}

model ServiceItem {
  id              String          @id @default(uuid())
  agreementId     String?         @map("agreement_id")
  caseId          String          @map("case_id")
  type            ServiceItemType

  // Service details
  description     String
  quantity        Float           @default(1)
  rate            Float           // Hourly rate or fixed amount
  amount          Float           // quantity * rate
  currency        String          @default("USD")

  // Billing
  isBillable      Boolean         @default(true) @map("is_billable")
  isBilled        Boolean         @default(false) @map("is_billed")
  billedDate      DateTime?       @map("billed_date")

  // Dates
  serviceDate     DateTime        @map("service_date")

  // Metadata
  notes           String?         @db.Text
  metadata        Json?

  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  agreement       Agreement?      @relation(fields: [agreementId], references: [id], onDelete: SetNull)
  case            Case            @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([agreementId])
  @@index([caseId])
  @@index([type])
  @@index([serviceDate])
  @@map("service_items")
}

model InvoiceFinance {
  id              String         @id @default(uuid())
  caseId          String         @map("case_id")
  invoiceNumber   String         @unique @map("invoice_number")

  // Financial details
  subtotal        Float
  taxRate         Float          @default(0) @map("tax_rate")
  taxAmount       Float          @default(0) @map("tax_amount")
  discountAmount  Float          @default(0) @map("discount_amount")
  totalAmount     Float          @map("total_amount")
  paidAmount      Float          @default(0) @map("paid_amount")
  balanceDue      Float          @map("balance_due")
  currency        String         @default("USD")

  // Status
  status          InvoiceStatus  @default(DRAFT)

  // Dates
  issueDate       DateTime       @map("issue_date")
  dueDate         DateTime       @map("due_date")
  paidDate        DateTime?      @map("paid_date")
  sentDate        DateTime?      @map("sent_date")
  viewedDate      DateTime?      @map("viewed_date")

  // Line items
  items           Json           // Array of invoice line items

  // Client details
  clientName      String         @map("client_name")
  clientEmail     String?        @map("client_email")
  clientAddress   String?        @map("client_address") @db.Text

  // Documents
  pdfUrl          String?        @map("pdf_url")

  // Metadata
  notes           String?        @db.Text
  internalNotes   String?        @db.Text @map("internal_notes")
  metadata        Json?

  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")

  case            Case           @relation(fields: [caseId], references: [id], onDelete: Cascade)
  payments        PaymentFinance[]

  @@index([caseId])
  @@index([status])
  @@index([issueDate])
  @@index([dueDate])
  @@map("finance_invoices")
}

model PaymentFinance {
  id              String            @id @default(uuid())
  invoiceId       String            @map("invoice_id")
  caseId          String            @map("case_id")

  // Payment details
  amount          Float
  currency        String            @default("USD")
  method          PaymentMethodType
  status          PaymentStatus     @default(PENDING)

  // Transaction details
  transactionId   String?           @map("transaction_id")
  referenceNumber String?           @map("reference_number")

  // Dates
  paymentDate     DateTime          @map("payment_date")
  receivedDate    DateTime?         @map("received_date")

  // Receipt
  receiptUrl      String?           @map("receipt_url")
  receiptNumber   String?           @map("receipt_number")

  // Metadata
  notes           String?           @db.Text
  metadata        Json?

  createdAt       DateTime          @default(now()) @map("created_at")
  updatedAt       DateTime          @updatedAt @map("updated_at")

  invoice         InvoiceFinance    @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  case            Case              @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@index([caseId])
  @@index([status])
  @@index([paymentDate])
  @@map("finance_payments")
}

model CaseFinance {
  id              String   @id @default(uuid())
  caseId          String   @unique @map("case_id")

  // Financial summary
  totalBilled     Float    @default(0) @map("total_billed")
  totalPaid       Float    @default(0) @map("total_paid")
  totalOutstanding Float   @default(0) @map("total_outstanding")
  totalExpenses   Float    @default(0) @map("total_expenses")

  // Counts
  invoiceCount    Int      @default(0) @map("invoice_count")
  paymentCount    Int      @default(0) @map("payment_count")

  // Dates
  lastInvoiceDate DateTime? @map("last_invoice_date")
  lastPaymentDate DateTime? @map("last_payment_date")

  // Metadata
  currency        String   @default("USD")
  notes           String?  @db.Text

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  case            Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@map("case_finances")
}

// ============================================================================
// DOCUMENT ANALYSIS & NOTIFICATION SYSTEM
// ============================================================================

model AnalysisQueue {
  id            String    @id @default(uuid())
  documentId    String    @map("document_id")
  documentType  String    @map("document_type") // 'LegalDocument' or 'Document'
  jobType       String    @map("job_type")
  status        String    @default("pending")
  priority      Int       @default(0)
  attempts      Int       @default(0)
  maxAttempts   Int       @default(3) @map("max_attempts")

  // Job data
  jobData       Json?     @map("job_data")
  result        Json?
  errorMessage  String?   @map("error_message") @db.Text

  // Timing
  scheduledAt   DateTime? @map("scheduled_at")
  startedAt     DateTime? @map("started_at")
  completedAt   DateTime? @map("completed_at")
  failedAt      DateTime? @map("failed_at")
  processingTimeMs Int?   @map("processing_time_ms")

  // Metadata
  createdBy     String?   @map("created_by")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  creator       User?     @relation(fields: [createdBy], references: [id], onDelete: SetNull)

  @@index([documentId])
  @@index([status])
  @@index([priority])
  @@index([scheduledAt])
  @@map("analysis_queue")
}

model DocumentRegistry {
  id                  String    @id @default(uuid())
  documentId          String    @map("document_id")
  documentType        String    @map("document_type") // 'LegalDocument' or 'Document'

  // Hierarchy information
  parentId            String?   @map("parent_id")
  hierarchyLevel      Int       @default(0) @map("hierarchy_level")
  hierarchyPath       String    @map("hierarchy_path")
  displayOrder        Int       @default(0) @map("display_order")

  // Document metadata
  title               String
  category            String?
  tags                String[]

  // Version control
  version             String?
  isCurrentVersion    Boolean   @default(true) @map("is_current_version")
  supersededBy        String?   @map("superseded_by")
  versionDate         DateTime? @map("version_date")

  // Access control
  isPublic            Boolean   @default(false) @map("is_public")
  accessLevel         String    @default("authenticated") @map("access_level")
  restrictedToRoles   String[]  @map("restricted_to_roles")

  // Search optimization
  searchVector        String?   @map("search_vector") @db.Text
  keywords            String[]

  // Statistics
  viewCount           Int       @default(0) @map("view_count")
  referenceCount      Int       @default(0) @map("reference_count")
  lastAccessed        DateTime? @map("last_accessed")

  // Timestamps
  registeredAt        DateTime  @default(now()) @map("registered_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  parent              DocumentRegistry?  @relation("DocumentHierarchy", fields: [parentId], references: [id])
  children            DocumentRegistry[] @relation("DocumentHierarchy")
  supersededByDoc     DocumentRegistry?  @relation("VersionControl", fields: [supersededBy], references: [id])
  supersedes          DocumentRegistry[] @relation("VersionControl")

  @@unique([documentId, documentType, version])
  @@index([documentId, documentType])
  @@index([parentId])
  @@index([hierarchyPath])
  @@index([isCurrentVersion])
  @@map("document_registry")
}

model DocumentReference {
  id                  String    @id @default(uuid())
  sourceDocumentId    String    @map("source_document_id")
  sourceDocumentType  String    @map("source_document_type")
  targetDocumentId    String?   @map("target_document_id")
  targetDocumentType  String?   @map("target_document_type")

  // Reference details
  referenceType       String    @map("reference_type") // cites, amends, repeals, implements, etc.
  referenceText       String?   @map("reference_text") @db.Text
  referenceLocation   String?   @map("reference_location") // article number, section, etc.

  // Validation
  isValid             Boolean   @default(true) @map("is_valid")
  validationDate      DateTime? @map("validation_date")
  validationError     String?   @map("validation_error") @db.Text

  createdAt           DateTime  @default(now()) @map("created_at")

  @@index([sourceDocumentId, sourceDocumentType])
  @@index([targetDocumentId, targetDocumentType])
  @@index([referenceType])
  @@map("document_references")
}

model LegalDocumentArticle {
  id                  String    @id @default(uuid())
  legalDocumentId     String    @map("legal_document_id")

  // Article identification
  articleNumber       Int       @map("article_number")
  articleNumberText   String?   @map("article_number_text") // For articles like "23-A"
  articleTitle        String?   @map("article_title") @db.Text

  // Content
  articleContent      String    @map("article_content") @db.Text
  wordCount           Int?      @map("word_count")

  // Structure
  parentSectionId     String?   @map("parent_section_id")
  displayOrder        Int?      @map("display_order")
  hierarchyLevel      Int       @default(4) @map("hierarchy_level")

  // Analysis results
  summary             String?   @db.Text
  keywords            Json?
  entities            Json?
  referencedArticles  Json?     @map("referenced_articles")

  // Embeddings for different strategies
  embedding           Json?
  summaryEmbedding    Json?     @map("summary_embedding")
  queryEmbedding      Json?     @map("query_embedding")

  createdAt           DateTime  @default(now()) @map("created_at")

  legalDocument       LegalDocument           @relation(fields: [legalDocumentId], references: [id], onDelete: Cascade)
  parentSection       LegalDocumentSection?   @relation("ArticleSections", fields: [parentSectionId], references: [id])
  summaries           LegalDocumentSummary[]

  @@index([legalDocumentId])
  @@index([articleNumber])
  @@index([parentSectionId])
  @@map("legal_document_articles")
}

model LegalDocumentSection {
  id                  String    @id @default(uuid())
  legalDocumentId     String    @map("legal_document_id")

  // Section identification
  sectionType         String    @map("section_type") // title, chapter, section
  sectionNumber       String    @map("section_number")
  sectionTitle        String?   @map("section_title") @db.Text

  // Hierarchy
  parentSectionId     String?   @map("parent_section_id")
  level               Int
  hierarchyPath       String?   @map("hierarchy_path")
  displayOrder        Int?      @map("display_order")

  // Content
  content             String?   @db.Text
  wordCount           Int?      @map("word_count")

  // Analysis
  summary             String?   @db.Text
  embedding           Json?

  createdAt           DateTime  @default(now()) @map("created_at")

  legalDocument       LegalDocument           @relation(fields: [legalDocumentId], references: [id], onDelete: Cascade)
  parentSection       LegalDocumentSection?   @relation("SectionHierarchy", fields: [parentSectionId], references: [id])
  childSections       LegalDocumentSection[]  @relation("SectionHierarchy")
  articles            LegalDocumentArticle[]  @relation("ArticleSections")
  summaries           LegalDocumentSummary[]

  @@index([legalDocumentId])
  @@index([sectionType])
  @@index([parentSectionId])
  @@index([hierarchyPath])
  @@map("legal_document_sections")
}

model LegalDocumentSummary {
  id                  String    @id @default(uuid())
  legalDocumentId     String    @map("legal_document_id")

  // Summary details
  summaryType         String    @map("summary_type") // executive, chapter, section, technical
  summaryLevel        String    @map("summary_level") // document, chapter, section, article
  summaryText         String    @map("summary_text") @db.Text

  // Associated structure element
  sectionId           String?   @map("section_id")
  articleId           String?   @map("article_id")

  // Metadata
  keyPoints           Json?     @map("key_points")
  confidenceScore     Float?    @map("confidence_score")

  // Embeddings
  embedding           Json?

  createdAt           DateTime  @default(now()) @map("created_at")

  legalDocument       LegalDocument         @relation(fields: [legalDocumentId], references: [id], onDelete: Cascade)
  section             LegalDocumentSection? @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  article             LegalDocumentArticle? @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([legalDocumentId])
  @@index([summaryType])
  @@index([summaryLevel])
  @@map("legal_document_summaries")
}

model QueryTemplate {
  id                  String    @id @default(uuid())
  pattern             String    @db.Text
  queryType           String    @map("query_type")
  responseTemplate    String?   @map("response_template") @db.Text

  // Associated documents
  documentIds         String[]  @map("document_ids")
  documentTypes       String[]  @map("document_types")

  // Metadata
  requiredFields      Json?     @map("required_fields")
  optionalFields      Json?     @map("optional_fields")
  priority            Int       @default(50)

  // Usage statistics
  useCount            Int       @default(0) @map("use_count")
  successRate         Float?    @map("success_rate")
  avgResponseTimeMs   Int?      @map("avg_response_time_ms")

  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  @@index([queryType])
  @@index([priority])
  @@map("query_templates")
}

model DocumentProcessingHistory {
  id                  String    @id @default(uuid())
  documentId          String    @map("document_id")
  documentType        String    @map("document_type")

  // Processing details
  processType         String    @map("process_type")
  processVersion      String?   @map("process_version")

  // Results
  status              String
  results             Json?
  errorDetails        Json?     @map("error_details")

  // Metrics
  processingTimeMs    Int?      @map("processing_time_ms")
  tokensUsed          Int?      @map("tokens_used")
  embeddingsGenerated Int?      @map("embeddings_generated")
  chunksCreated       Int?      @map("chunks_created")

  // Timestamps
  startedAt           DateTime  @map("started_at")
  completedAt         DateTime? @map("completed_at")
  createdAt           DateTime  @default(now()) @map("created_at")

  @@index([documentId, documentType])
  @@index([status])
  @@index([createdAt])
  @@map("document_processing_history")
}

model NotificationSubscription {
  id                  String    @id @default(uuid())
  userId              String    @map("user_id")

  // Subscription preferences
  subscriptionType    String    @map("subscription_type") // document_upload, analysis_complete, etc.
  channel             String                             // email, in_app, sms, webhook

  // Filters
  documentTypes       String[]  @map("document_types")
  categories          String[]
  keywords            String[]

  // Configuration
  isActive            Boolean   @default(true) @map("is_active")
  frequency           String    @default("immediate") // immediate, daily, weekly
  quietHoursStart     DateTime? @map("quiet_hours_start") @db.Time
  quietHoursEnd       DateTime? @map("quiet_hours_end") @db.Time

  // Webhook configuration (if channel = webhook)
  webhookUrl          String?   @map("webhook_url")
  webhookSecret       String?   @map("webhook_secret")

  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  user                User      @relation("NotificationSubscriptions", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([subscriptionType])
  @@index([isActive])
  @@map("notification_subscriptions")
}

model NotificationQueue {
  id                  String    @id @default(uuid())

  // Notification details
  templateId          String?   @map("template_id")
  channel             String
  recipientId         String?   @map("recipient_id")
  recipientEmail      String?   @map("recipient_email")
  recipientPhone      String?   @map("recipient_phone")

  // Content
  subject             String?   @db.Text
  body                String    @db.Text
  data                Json?

  // Scheduling
  priority            String    @default("normal")
  scheduledAt         DateTime? @map("scheduled_at")

  // Status
  status              String    @default("pending")
  attempts            Int       @default(0)
  maxAttempts         Int       @default(3) @map("max_attempts")

  // Results
  sentAt              DateTime? @map("sent_at")
  deliveredAt         DateTime? @map("delivered_at")
  failedAt            DateTime? @map("failed_at")
  errorMessage        String?   @map("error_message") @db.Text

  createdAt           DateTime  @default(now()) @map("created_at")

  template            NotificationTemplate? @relation("NotificationQueueTemplate", fields: [templateId], references: [id])
  recipient           User?                 @relation("NotificationQueueRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([scheduledAt])
  @@index([priority])
  @@map("notification_queue")
}

// ============================================================================
// PHASE 7: USER FEEDBACK LOOP
// Track user interactions, click-through rates, relevance feedback, and A/B testing
// ============================================================================

model SearchInteraction {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  query           String
  timestamp       DateTime  @default(now())
  resultsCount    Int       @default(0) @map("results_count")
  filters         Json?
  sortBy          String?   @map("sort_by")
  sessionId       String?   @map("session_id")
  userAgent       String?   @map("user_agent")
  ipAddress       String?   @map("ip_address")

  // Relations
  user            User                @relation("SearchInteractions", fields: [userId], references: [id], onDelete: Cascade)
  clickEvents     ClickEvent[]        @relation("SearchClickEvents")
  relevanceFeedback RelevanceFeedback[] @relation("SearchRelevanceFeedback")

  @@index([userId, timestamp(sort: Desc)])
  @@index([sessionId])
  @@map("search_interactions")
}

model ClickEvent {
  id                    String    @id @default(uuid())
  searchInteractionId   String    @map("search_interaction_id")
  documentId            String    @map("document_id")
  position              Int
  relevanceScore        Float?    @map("relevance_score")
  timestamp             DateTime  @default(now())
  dwellTime             Int?      @map("dwell_time") // milliseconds

  // Relations
  searchInteraction     SearchInteraction @relation("SearchClickEvents", fields: [searchInteractionId], references: [id], onDelete: Cascade)
  document              LegalDocument     @relation("DocumentClickEvents", fields: [documentId], references: [id], onDelete: Cascade)

  @@index([searchInteractionId])
  @@index([documentId])
  @@index([timestamp(sort: Desc)])
  @@map("click_events")
}

model RelevanceFeedback {
  id                    String    @id @default(uuid())
  searchInteractionId   String    @map("search_interaction_id")
  documentId            String    @map("document_id")
  rating                Int       // 1-5 stars
  isRelevant            Boolean?  @map("is_relevant")
  comment               String?   @db.Text
  timestamp             DateTime  @default(now())

  // Relations
  searchInteraction     SearchInteraction @relation("SearchRelevanceFeedback", fields: [searchInteractionId], references: [id], onDelete: Cascade)
  document              LegalDocument     @relation("DocumentRelevanceFeedback", fields: [documentId], references: [id], onDelete: Cascade)

  @@index([searchInteractionId])
  @@index([documentId])
  @@map("relevance_feedback")
}

model ABTestConfig {
  id              String    @id @default(uuid())
  name            String    @unique
  description     String?   @db.Text
  isActive        Boolean   @default(true) @map("is_active")
  startDate       DateTime  @default(now()) @map("start_date")
  endDate         DateTime? @map("end_date")
  variants        Json      // Array of scoring weight configurations
  trafficSplit    Json      @map("traffic_split") // Percentage allocation per variant
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  assignments     ABTestAssignment[] @relation("ABTestAssignments")

  @@map("ab_test_configs")
}

model ABTestAssignment {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  testConfigId    String    @map("test_config_id")
  variant         String
  assignedAt      DateTime  @default(now()) @map("assigned_at")

  // Relations
  user            User          @relation("UserABTestAssignments", fields: [userId], references: [id], onDelete: Cascade)
  testConfig      ABTestConfig  @relation("ABTestAssignments", fields: [testConfigId], references: [id], onDelete: Cascade)

  @@unique([userId, testConfigId])
  @@index([userId, testConfigId])
  @@map("ab_test_assignments")
}

// ============================================================================
// PHASE 8: CROSS-REFERENCE GRAPH
// Track document citations, relationships, and authority scores (PageRank)
// ============================================================================

enum CitationType {
  REFERENCE
  AMENDMENT
  REPEAL
  SUPERSEDES
  IMPLEMENTS
  JUDICIAL_PRECEDENT
}

enum RelationshipType {
  SUPERSEDES
  AMENDS
  IMPLEMENTS
  RELATED_TO
  PRECEDENT
  CONSOLIDATES
}

enum ExtractionMethod {
  AUTOMATIC
  MANUAL
  AI_ASSISTED
}

model DocumentCitation {
  id                String        @id @default(uuid())
  sourceDocumentId  String        @map("source_document_id")
  targetDocumentId  String?       @map("target_document_id")

  // Citation details
  citationText      String?       @map("citation_text") @db.Text
  citationContext   String?       @map("citation_context") @db.Text
  articleReference  String?       @map("article_reference")
  sectionReference  String?       @map("section_reference")

  // Citation type and strength
  citationType      CitationType  @default(REFERENCE) @map("citation_type")
  citationStrength  Float         @default(1.0) @map("citation_strength")
  confidenceScore   Float?        @map("confidence_score")

  // Extraction metadata
  extractedBy       ExtractionMethod @default(AUTOMATIC) @map("extracted_by")
  extractionMethod  String?       @map("extraction_method")
  isValidated       Boolean       @default(false) @map("is_validated")
  validatedBy       String?       @map("validated_by")
  validatedAt       DateTime?     @map("validated_at")
  validationNotes   String?       @map("validation_notes") @db.Text

  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")

  // Relations
  sourceDocument    LegalDocument @relation("SourceCitations", fields: [sourceDocumentId], references: [id], onDelete: Cascade)
  targetDocument    LegalDocument? @relation("TargetCitations", fields: [targetDocumentId], references: [id], onDelete: SetNull)

  @@index([sourceDocumentId])
  @@index([targetDocumentId])
  @@index([citationType])
  @@index([isValidated])
  @@index([createdAt(sort: Desc)])
  @@map("document_citations")
}

model DocumentRelationship {
  id                  String           @id @default(uuid())
  sourceDocumentId    String           @map("source_document_id")
  targetDocumentId    String           @map("target_document_id")

  // Relationship details
  relationshipType    RelationshipType @map("relationship_type")
  relationshipStrength Float           @default(1.0) @map("relationship_strength")
  description         String?          @db.Text

  // Temporal information
  effectiveDate       DateTime?        @map("effective_date")
  endDate             DateTime?        @map("end_date")
  isActive            Boolean          @default(true) @map("is_active")

  // Metadata
  metadata            Json?
  createdBy           String?          @map("created_by")
  createdAt           DateTime         @default(now()) @map("created_at")
  updatedAt           DateTime         @updatedAt @map("updated_at")

  // Relations
  sourceDocument      LegalDocument    @relation("SourceRelationships", fields: [sourceDocumentId], references: [id], onDelete: Cascade)
  targetDocument      LegalDocument    @relation("TargetRelationships", fields: [targetDocumentId], references: [id], onDelete: Cascade)

  @@index([sourceDocumentId])
  @@index([targetDocumentId])
  @@index([relationshipType])
  @@index([isActive])
  @@index([effectiveDate(sort: Desc)])
  @@map("document_relationships")
}

model DocumentAuthorityScore {
  id                    String        @id @default(uuid())
  documentId            String        @unique @map("document_id")

  // PageRank scores
  pagerankScore         Float         @default(0.15) @map("pagerank_score")
  weightedPagerank      Float         @default(0.15) @map("weighted_pagerank")
  personalizedPagerank  Float?        @map("personalized_pagerank")

  // Other authority metrics
  citationCount         Int           @default(0) @map("citation_count")
  citationInCount       Int           @default(0) @map("citation_in_count")
  citationOutCount      Int           @default(0) @map("citation_out_count")
  hIndex                Int           @default(0) @map("h_index")

  // Impact metrics
  impactScore           Float?        @map("impact_score")
  recencyFactor         Float?        @map("recency_factor")
  combinedAuthority     Float?        @map("combined_authority")

  // Calculation metadata
  lastCalculated        DateTime?     @map("last_calculated")
  calculationVersion    String?       @map("calculation_version")
  convergenceIterations Int?          @map("convergence_iterations")

  createdAt             DateTime      @default(now()) @map("created_at")
  updatedAt             DateTime      @updatedAt @map("updated_at")

  // Relation
  document              LegalDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([pagerankScore(sort: Desc)])
  @@index([combinedAuthority(sort: Desc)])
  @@index([citationCount(sort: Desc)])
  @@index([lastCalculated(sort: Desc)])
  @@map("document_authority_scores")
}

model CitationExtractionJob {
  id                  String        @id @default(uuid())
  documentId          String        @map("document_id")

  // Job details
  status              String        @default("pending") @map("status") // pending, processing, completed, failed
  priority            Int           @default(5)
  extractionMethod    String        @default("regex") @map("extraction_method") // regex, nlp, hybrid, manual

  // Results
  citationsFound      Int?          @map("citations_found")
  citationsValidated  Int?          @map("citations_validated")
  processingTimeMs    Int?          @map("processing_time_ms")
  errorMessage        String?       @map("error_message") @db.Text

  // Job metadata
  attempts            Int           @default(0)
  maxAttempts         Int           @default(3) @map("max_attempts")
  startedAt           DateTime?     @map("started_at")
  completedAt         DateTime?     @map("completed_at")
  failedAt            DateTime?     @map("failed_at")

  createdAt           DateTime      @default(now()) @map("created_at")
  updatedAt           DateTime      @updatedAt @map("updated_at")

  // Relation
  document            LegalDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([status])
  @@index([priority(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("citation_extraction_jobs")
}

model PageRankCalculationLog {
  id                    String    @id @default(uuid())

  // Calculation parameters
  dampingFactor         Float     @default(0.85) @map("damping_factor")
  maxIterations         Int       @default(100) @map("max_iterations")
  convergenceThreshold  Float     @default(0.0001) @map("convergence_threshold")

  // Results
  documentsProcessed    Int       @default(0) @map("documents_processed")
  iterationsRun         Int?      @map("iterations_run")
  converged             Boolean   @default(false)
  avgPagerank           Float?    @map("avg_pagerank")
  maxPagerank           Float?    @map("max_pagerank")
  minPagerank           Float?    @map("min_pagerank")

  // Performance
  processingTimeMs      Int?      @map("processing_time_ms")
  calculationMethod     String?   @default("iterative") @map("calculation_method") // iterative, power_iteration, monte_carlo

  // Metadata
  triggeredBy           String?   @map("triggered_by")
  notes                 String?   @db.Text

  startedAt             DateTime  @map("started_at")
  completedAt           DateTime? @map("completed_at")
  createdAt             DateTime  @default(now()) @map("created_at")

  @@index([startedAt(sort: Desc)])
  @@index([converged])
  @@map("pagerank_calculation_logs")
}

// ============================================================================
// PHASE 9: ADVANCED SEARCH & USER EXPERIENCE ENHANCEMENT
// Advanced search with re-ranking, collections, sharing, and recommendations
// ============================================================================

enum RecommendationType {
  SIMILAR
  CITED_TOGETHER
  COLLABORATIVE
  PERSONALIZED
}

model SavedSearch {
  id            String    @id @default(uuid())
  userId        String    @map("user_id")
  query         String
  filters       Json?
  resultsCount  Int?      @map("results_count")
  isFavorite    Boolean   @default(false) @map("is_favorite")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relation
  user          User      @relation("UserSavedSearches", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@index([isFavorite])
  @@map("saved_searches")
}

model DocumentCollection {
  id            String    @id @default(uuid())
  userId        String    @map("user_id")
  name          String
  description   String?   @db.Text
  isPublic      Boolean   @default(false) @map("is_public")
  shareToken    String?   @unique @map("share_token")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  user          User                  @relation("UserCollections", fields: [userId], references: [id], onDelete: Cascade)
  documents     CollectionDocument[]  @relation("CollectionDocuments")

  @@index([userId])
  @@index([isPublic])
  @@index([shareToken])
  @@map("document_collections")
}

model CollectionDocument {
  collectionId  String    @map("collection_id")
  documentId    String    @map("document_id")
  addedAt       DateTime  @default(now()) @map("added_at")
  notes         String?   @db.Text

  // Relations
  collection    DocumentCollection @relation("CollectionDocuments", fields: [collectionId], references: [id], onDelete: Cascade)
  document      LegalDocument      @relation("DocumentInCollections", fields: [documentId], references: [id], onDelete: Cascade)

  @@id([collectionId, documentId])
  @@index([collectionId])
  @@index([documentId])
  @@map("collection_documents")
}

model SearchSuggestion {
  id              String    @id @default(uuid())
  suggestionText  String    @unique @map("suggestion_text")
  searchCount     Int       @default(1) @map("search_count")
  lastUsed        DateTime  @default(now()) @map("last_used")
  category        String?   // legal_term, document_title, case_name, etc.
  createdAt       DateTime  @default(now()) @map("created_at")

  @@index([suggestionText])
  @@index([searchCount(sort: Desc)])
  @@index([category])
  @@map("search_suggestions")
}

model SharedSearchLink {
  id            String    @id @default(uuid())
  shareToken    String    @unique @map("share_token")
  userId        String?   @map("user_id")
  searchQuery   String    @map("search_query")
  filters       Json?
  resultIds     String[]  @map("result_ids")
  expiresAt     DateTime? @map("expires_at")
  accessCount   Int       @default(0) @map("access_count")
  createdAt     DateTime  @default(now()) @map("created_at")

  // Relation
  user          User?     @relation("UserSharedLinks", fields: [userId], references: [id], onDelete: SetNull)

  @@index([shareToken])
  @@index([userId])
  @@index([expiresAt])
  @@map("shared_search_links")
}

model DocumentRecommendation {
  id                      String             @id @default(uuid())
  sourceDocumentId        String             @map("source_document_id")
  recommendedDocumentId   String             @map("recommended_document_id")
  recommendationType      RecommendationType @map("recommendation_type")
  score                   Float
  reason                  String?            @db.Text
  calculatedAt            DateTime           @default(now()) @map("calculated_at")

  // Relations
  sourceDocument          LegalDocument      @relation("SourceRecommendations", fields: [sourceDocumentId], references: [id], onDelete: Cascade)
  recommendedDocument     LegalDocument      @relation("RecommendedDocuments", fields: [recommendedDocumentId], references: [id], onDelete: Cascade)

  @@index([sourceDocumentId])
  @@index([recommendationType])
  @@index([score(sort: Desc)])
  @@map("document_recommendations")
}

model QueryExpansion {
  id            String    @id @default(uuid())
  originalTerm  String    @map("original_term")
  expandedTerms String[]  @map("expanded_terms")
  context       String?   // legal_area, jurisdiction, etc.
  usageCount    Int       @default(0) @map("usage_count")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([originalTerm])
  @@index([usageCount(sort: Desc)])
  @@map("query_expansions")
}

// ============================================================================
// PHASE 10: AI-POWERED LEGAL ASSISTANT & ADVANCED ANALYTICS
// AI chat conversations, NLP query processing, analytics, and ML predictions
// ============================================================================

// AI Conversation Management
model AIConversation {
  id            String      @id @default(uuid())
  userId        String      @map("user_id")
  title         String?
  startedAt     DateTime    @default(now()) @map("started_at")
  lastMessageAt DateTime    @updatedAt @map("last_message_at")
  messageCount  Int         @default(0) @map("message_count")
  isActive      Boolean     @default(true) @map("is_active")

  // Relations
  user          User        @relation("UserAIConversations", fields: [userId], references: [id], onDelete: Cascade)
  messages      AIMessage[] @relation("ConversationMessages")

  @@index([userId, startedAt(sort: Desc)])
  @@index([userId, isActive])
  @@map("ai_conversations")
}

model AIMessage {
  id              String          @id @default(uuid())
  conversationId  String          @map("conversation_id")
  role            String          // "user" | "assistant" | "system"
  content         String          @db.Text
  timestamp       DateTime        @default(now())

  // NLP Analysis
  intent          String?
  confidence      Float?
  processingTimeMs Int?           @map("processing_time_ms")

  // Citations
  citedDocuments  Json?           @map("cited_documents")
  citedChunks     Json?           @map("cited_chunks")

  // Feedback
  wasHelpful      Boolean?        @map("was_helpful")
  feedbackText    String?         @db.Text @map("feedback_text")

  // Relations
  conversation    AIConversation  @relation("ConversationMessages", fields: [conversationId], references: [id], onDelete: Cascade)
  citations       AICitation[]    @relation("MessageCitations")

  @@index([conversationId, timestamp])
  @@index([role])
  @@map("ai_messages")
}

model AICitation {
  id          String        @id @default(uuid())
  messageId   String        @map("message_id")
  documentId  String        @map("document_id")
  chunkId     String?       @map("chunk_id")
  relevance   Float         @default(1.0)
  articleRef  String?       @map("article_ref")
  timestamp   DateTime      @default(now())

  // Relations
  message     AIMessage     @relation("MessageCitations", fields: [messageId], references: [id], onDelete: Cascade)
  document    LegalDocument @relation("AIDocumentCitations", fields: [documentId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([documentId])
  @@index([relevance(sort: Desc)])
  @@map("ai_citations")
}

// Analytics & Metrics
model AnalyticsEvent {
  id           String    @id @default(uuid())
  eventType    String    @map("event_type") // "search", "document_view", "ai_query", "download", "citation"
  userId       String?   @map("user_id")
  sessionId    String    @map("session_id")
  timestamp    DateTime  @default(now())
  metadata     Json?
  durationMs   Int?      @map("duration_ms")
  success      Boolean   @default(true)

  // Relations
  user         User?     @relation("UserAnalyticsEvents", fields: [userId], references: [id], onDelete: SetNull)

  @@index([eventType, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
  @@index([sessionId])
  @@map("analytics_events")
}

model AnalyticsMetric {
  id           String    @id @default(uuid())
  metricName   String    @map("metric_name")
  metricValue  Float     @map("metric_value")
  dimensions   Json?     // Additional dimensions for filtering
  timestamp    DateTime  @default(now())
  periodStart  DateTime  @map("period_start")
  periodEnd    DateTime  @map("period_end")

  @@index([metricName, timestamp(sort: Desc)])
  @@index([periodStart, periodEnd])
  @@map("analytics_metrics")
}

model DocumentAnalytics {
  id               String        @id @default(uuid())
  documentId       String        @map("document_id")
  viewCount        Int           @default(0) @map("view_count")
  searchCount      Int           @default(0) @map("search_count")
  citationCount    Int           @default(0) @map("citation_count")
  downloadCount    Int           @default(0) @map("download_count")
  avgTimeSpent     Float?        @map("avg_time_spent")
  bounceRate       Float?        @map("bounce_rate")
  relevanceScore   Float?        @map("relevance_score")
  lastViewed       DateTime?     @map("last_viewed")
  lastCited        DateTime?     @map("last_cited")
  trendingScore    Float?        @map("trending_score")
  periodStart      DateTime      @map("period_start")
  periodEnd        DateTime      @map("period_end")

  // Relations
  document         LegalDocument @relation("DocumentAnalytics", fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, periodStart])
  @@index([trendingScore(sort: Desc)])
  @@index([viewCount(sort: Desc)])
  @@map("document_analytics")
}

model SearchAnalytics {
  id              String    @id @default(uuid())
  query           String
  resultCount     Int       @map("result_count")
  clickThroughRate Float?   @map("click_through_rate")
  avgPosition     Float?    @map("avg_position")
  searchCount     Int       @default(1) @map("search_count")
  lastSearched    DateTime  @default(now()) @map("last_searched")

  @@index([query])
  @@index([searchCount(sort: Desc)])
  @@index([clickThroughRate(sort: Desc)])
  @@map("search_analytics")
}

// Machine Learning & Predictions
model MLModel {
  id          String       @id @default(uuid())
  name        String
  type        String       // "outcome_predictor", "trend_forecaster", "pattern_detector"
  version     String
  trainedAt   DateTime     @map("trained_at")
  accuracy    Float?
  precision   Float?
  recall      Float?
  config      Json
  trainingSet Json?        @map("training_set")
  isActive    Boolean      @default(true) @map("is_active")

  // Relations
  predictions  Prediction[] @relation("ModelPredictions")

  @@index([type, isActive])
  @@map("ml_models")
}

model Prediction {
  id             String    @id @default(uuid())
  modelId        String    @map("model_id")
  predictionType String    @map("prediction_type")
  inputData      Json      @map("input_data")
  prediction     Json
  confidence     Float
  timestamp      DateTime  @default(now())

  // Relations
  model          MLModel   @relation("ModelPredictions", fields: [modelId], references: [id], onDelete: Cascade)

  @@index([modelId])
  @@index([confidence(sort: Desc)])
  @@index([timestamp(sort: Desc)])
  @@map("predictions")
}

model LegalPattern {
  id          String    @id @default(uuid())
  patternType String    @map("pattern_type") // "amendment", "trend", "precedent", "correlation"
  title       String
  description String    @db.Text
  confidence  Float
  impact      String    // "high", "medium", "low"
  timeframe   Json
  evidence    Json
  detectedAt  DateTime  @default(now()) @map("detected_at")
  detectedBy  String    @map("detected_by")
  isActive    Boolean   @default(true) @map("is_active")
  verified    Boolean   @default(false)
  verifiedBy  String?   @map("verified_by")
  verifiedAt  DateTime? @map("verified_at")

  @@index([patternType, detectedAt(sort: Desc)])
  @@index([confidence(sort: Desc)])
  @@map("legal_patterns")
}

model TrendForecast {
  id              String    @id @default(uuid())
  forecastType    String    @map("forecast_type")
  targetMetric    String    @map("target_metric")
  forecastPeriod  String    @map("forecast_period")
  predictedValue  Float     @map("predicted_value")
  confidence      Float
  factors         Json
  createdAt       DateTime  @default(now()) @map("created_at")
  expiresAt       DateTime  @map("expires_at")

  @@index([forecastType])
  @@index([confidence(sort: Desc)])
  @@index([expiresAt])
  @@map("trend_forecasts")
}

// Document Summarization & Analysis
model DocumentSummary {
  id            String        @id @default(uuid())
  documentId    String        @map("document_id")
  summaryType   String        @map("summary_type") // "executive", "technical", "key_points"
  summary       String        @db.Text
  keyPoints     Json?         @map("key_points")
  generatedAt   DateTime      @default(now()) @map("generated_at")
  generatedBy   String        @map("generated_by") // "ai", "human"
  version       String        @default("1.0")

  // Relations
  document      LegalDocument @relation("DocumentSummaries", fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([summaryType])
  @@map("document_summaries")
}

model ArticleAnalysis {
  id               String        @id @default(uuid())
  documentId       String        @map("document_id")
  articleNumber    String        @map("article_number")
  analysisType     String        @map("analysis_type") // "complexity", "impact", "precedent"
  analysis         Json
  score            Float?
  generatedAt      DateTime      @default(now()) @map("generated_at")

  // Relations
  document         LegalDocument @relation("DocumentArticleAnalysis", fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([analysisType])
  @@map("article_analysis")
}

model DocumentComparison {
  id              String    @id @default(uuid())
  document1Id     String    @map("document1_id")
  document2Id     String    @map("document2_id")
  similarityScore Float     @map("similarity_score")
  differences     Json
  similarities    Json
  comparedAt      DateTime  @default(now()) @map("compared_at")
  comparedBy      String?   @map("compared_by")

  @@index([document1Id])
  @@index([document2Id])
  @@index([similarityScore(sort: Desc)])
  @@map("document_comparisons")
}

// ============================================================================
// PHASE 10 - WEEK 3: NLP-RAG INTEGRATION & CACHING
// Query history, session management, caching, and relevance feedback
// ============================================================================

// Query History for analytics and suggestions
model QueryHistory {
  id              String   @id @default(cuid())
  sessionId       String   @map("session_id")
  userId          String?  @map("user_id")
  query           String
  queryHash       String   @map("query_hash")
  intent          Json     // QueryIntent from NLP
  entities        Json     // Extracted entities
  filters         Json     // Applied filters
  resultsCount    Int      @map("results_count")
  clickedResults  Json[]   @map("clicked_results") // Result IDs that were clicked
  responseTime    Int      @map("response_time") // milliseconds
  cacheHit        Boolean  @default(false) @map("cache_hit")
  createdAt       DateTime @default(now()) @map("created_at")

  session         UserSession?  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user            User?         @relation("UserQueryHistory", fields: [userId], references: [id], onDelete: SetNull)
  cache           QueryCache?   @relation(fields: [queryHash], references: [queryHash])

  @@index([sessionId, createdAt])
  @@index([userId, createdAt])
  @@index([queryHash])
  @@index([createdAt])
  @@map("query_history")
}

// User Sessions for context tracking
model UserSession {
  id              String   @id @default(cuid())
  userId          String?  @map("user_id")
  sessionToken    String   @unique @map("session_token")
  ipAddress       String?  @map("ip_address")
  userAgent       String?  @map("user_agent")
  isActive        Boolean  @default(true) @map("is_active")
  queries         QueryHistory[]
  context         Json     @default("{}") // Accumulated context
  startedAt       DateTime @default(now()) @map("started_at")
  lastActivityAt  DateTime @default(now()) @map("last_activity_at")
  endedAt         DateTime? @map("ended_at")

  user            User?    @relation("UserSessions", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive, lastActivityAt])
  @@index([sessionToken])
  @@index([lastActivityAt])
  @@map("user_sessions")
}

// Query Cache for L3 persistent caching
model QueryCache {
  id              String   @id @default(cuid())
  queryHash       String   @unique @map("query_hash") // MD5 of normalized query + filters
  query           String
  filters         Json
  cachedResponse  Json     @map("cached_response") // Full search response
  hitCount        Int      @default(0) @map("hit_count")
  lastHitAt       DateTime @default(now()) @map("last_hit_at")
  expiresAt       DateTime @map("expires_at")
  createdAt       DateTime @default(now()) @map("created_at")

  history         QueryHistory[]

  @@index([queryHash, createdAt])
  @@index([expiresAt])
  @@index([lastHitAt])
  @@map("query_cache")
}

// Query Suggestions based on history
model QuerySuggestion {
  id              String   @id @default(cuid())
  suggestion      String   @unique
  category        String   // "popular", "related", "autocomplete"
  frequency       Int      @default(1)
  lastUsedAt      DateTime @default(now()) @map("last_used_at")
  createdAt       DateTime @default(now()) @map("created_at")

  @@index([category, frequency])
  @@index([suggestion])
  @@map("query_suggestions")
}
