generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(uuid())
  email           String    @unique
  name            String?
  passwordHash    String    @map("password_hash")
  role            String    @default("user")
  planTier        String    @default("free") @map("plan_tier")
  isActive        Boolean   @default(true) @map("is_active")
  lastLogin       DateTime? @map("last_login")
  storageUsedMB   Float     @default(0) @map("storage_used_mb")
  totalQueries    Int       @default(0) @map("total_queries")
  avatarUrl       String?   @map("avatar_url")
  phoneNumber     String?   @map("phone_number")
  address         String?
  city            String?
  country         String?   @default("Ecuador")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  cases           Case[]
  documents       Document[]
  legalDocuments  LegalDocument[]
  quota           UserQuota?
  apiKeys         ApiKey[]
  notifications   Notification[]
  auditLogs       AuditLog[]
  queryLogs       QueryLog[]
  storageUsage    StorageUsage[]
  subscriptions   Subscription[]
  payments        Payment[]
  paymentProofs   PaymentProof[]
  reviewedPaymentProofs PaymentProof[] @relation("ReviewedPaymentProofs")

  @@map("users")
}

model Case {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  title       String
  description String?
  clientName  String?  @map("client_name")
  caseNumber  String?  @map("case_number")
  status      String   @default("active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  documents   Document[]

  @@map("cases")
}

model Document {
  id          String   @id @default(uuid())
  caseId      String   @map("case_id")
  userId      String   @map("user_id")
  title       String
  content     String   @db.Text
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  case        Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  chunks      DocumentChunk[]

  @@map("documents")
}

model DocumentChunk {
  id          String   @id @default(uuid())
  documentId  String   @map("document_id")
  content     String   @db.Text
  chunkIndex  Int      @map("chunk_index")
  embedding   Json?
  createdAt   DateTime @default(now()) @map("created_at")

  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@map("document_chunks")
}

model LegalDocument {
  id          String   @id @default(uuid())
  title       String
  category    String
  content     String   @db.Text
  metadata    Json?
  uploadedBy  String   @map("uploaded_by")
  isActive    Boolean  @default(true) @map("is_active")
  viewCount   Int      @default(0) @map("view_count")
  downloadCount Int    @default(0) @map("download_count")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  uploader    User     @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)
  chunks      LegalDocumentChunk[]
  specialties DocumentSpecialty[]

  @@map("legal_documents")
}

model LegalDocumentChunk {
  id               String   @id @default(uuid())
  legalDocumentId  String   @map("legal_document_id")
  content          String   @db.Text
  chunkIndex       Int      @map("chunk_index")
  embedding        Json?
  createdAt        DateTime @default(now()) @map("created_at")

  legalDocument    LegalDocument @relation(fields: [legalDocumentId], references: [id], onDelete: Cascade)

  @@index([legalDocumentId])
  @@map("legal_document_chunks")
}

// Legal Specialties - Hierarchical structure for legal areas
model LegalSpecialty {
  id              String   @id @default(uuid())
  code            String   @unique
  name            String
  nameEnglish     String?  @map("name_english")
  description     String?  @db.Text
  parentId        String?  @map("parent_id")
  level           Int      @default(1)
  displayOrder    Int      @default(0) @map("display_order")
  isActive        Boolean  @default(true) @map("is_active")
  icon            String?
  color           String?
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  parent          LegalSpecialty?  @relation("SpecialtyHierarchy", fields: [parentId], references: [id])
  children        LegalSpecialty[] @relation("SpecialtyHierarchy")
  documents       DocumentSpecialty[]

  @@index([parentId])
  @@index([code])
  @@map("legal_specialties")
}

// Join table for LegalDocument and LegalSpecialty (many-to-many)
model DocumentSpecialty {
  id              String   @id @default(uuid())
  documentId      String   @map("document_id")
  specialtyId     String   @map("specialty_id")
  isPrimary       Boolean  @default(false) @map("is_primary")
  createdAt       DateTime @default(now()) @map("created_at")

  document        LegalDocument  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  specialty       LegalSpecialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  @@unique([documentId, specialtyId])
  @@index([documentId])
  @@index([specialtyId])
  @@map("document_specialties")
}

// Audit Log - Tracks all admin actions
model AuditLog {
  id          String   @id @default(uuid())
  userId      String?  @map("user_id")
  action      String
  entity      String
  entityId    String?  @map("entity_id")
  changes     Json?
  ipAddress   String?  @map("ip_address")
  userAgent   String?  @map("user_agent")
  success     Boolean  @default(true)
  errorMessage String? @map("error_message")
  createdAt   DateTime @default(now()) @map("created_at")

  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([entity])
  @@index([createdAt])
  @@map("audit_logs")
}

// Query Log - Tracks RAG queries for analytics
model QueryLog {
  id              String   @id @default(uuid())
  userId          String?  @map("user_id")
  query           String   @db.Text
  response        String?  @db.Text
  documentsFound  Int      @default(0) @map("documents_found")
  responseTime    Int      @map("response_time")
  tokensUsed      Int      @default(0) @map("tokens_used")
  model           String?
  success         Boolean  @default(true)
  errorMessage    String?  @map("error_message")
  ipAddress       String?  @map("ip_address")
  createdAt       DateTime @default(now()) @map("created_at")

  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([createdAt])
  @@map("query_logs")
}

// User Quota - Storage and usage limits per user
model UserQuota {
  id                String   @id @default(uuid())
  userId            String   @unique @map("user_id")
  storageGB         Float    @default(5.0) @map("storage_gb")
  storageUsedGB     Float    @default(0.0) @map("storage_used_gb")
  documentsLimit    Int      @default(100) @map("documents_limit")
  documentsUsed     Int      @default(0) @map("documents_used")
  monthlyQueries    Int      @default(1000) @map("monthly_queries")
  queriesUsedMonth  Int      @default(0) @map("queries_used_month")
  apiCallsLimit     Int      @default(10000) @map("api_calls_limit")
  apiCallsUsed      Int      @default(0) @map("api_calls_used")
  resetDate         DateTime @map("reset_date")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_quotas")
}

// Storage Usage - Detailed storage tracking per user
model StorageUsage {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  category        String
  sizeMB          Float    @map("size_mb")
  fileCount       Int      @default(0) @map("file_count")
  lastCalculated  DateTime @default(now()) @map("last_calculated")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([category])
  @@map("storage_usage")
}

// System Metrics - Platform-wide statistics
model SystemMetric {
  id              String   @id @default(uuid())
  metricName      String   @map("metric_name")
  metricValue     Float    @map("metric_value")
  metricUnit      String?  @map("metric_unit")
  category        String
  timestamp       DateTime @default(now())
  metadata        Json?

  @@index([metricName])
  @@index([category])
  @@index([timestamp])
  @@map("system_metrics")
}

// Database Stats - PostgreSQL database statistics
model DatabaseStats {
  id              String   @id @default(uuid())
  tableName       String   @map("table_name")
  rowCount        Int      @map("row_count")
  sizeMB          Float    @map("size_mb")
  indexSizeMB     Float    @default(0) @map("index_size_mb")
  lastVacuum      DateTime? @map("last_vacuum")
  lastAnalyze     DateTime? @map("last_analyze")
  timestamp       DateTime @default(now())

  @@index([tableName])
  @@index([timestamp])
  @@map("database_stats")
}

// API Keys - For programmatic access
model ApiKey {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  name            String
  keyHash         String   @unique @map("key_hash")
  lastUsed        DateTime? @map("last_used")
  expiresAt       DateTime? @map("expires_at")
  isActive        Boolean  @default(true) @map("is_active")
  permissions     Json?
  usageCount      Int      @default(0) @map("usage_count")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([keyHash])
  @@map("api_keys")
}

// Notifications - System notifications for users
model Notification {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  type            String
  title           String
  message         String   @db.Text
  priority        String   @default("normal")
  isRead          Boolean  @default(false) @map("is_read")
  readAt          DateTime? @map("read_at")
  actionUrl       String?  @map("action_url")
  metadata        Json?
  createdAt       DateTime @default(now()) @map("created_at")

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

// Subscription Plans - Available pricing tiers
model SubscriptionPlan {
  id                String   @id @default(uuid())
  code              String   @unique
  name              String
  nameEnglish       String   @map("name_english")
  description       String?  @db.Text
  priceMonthlyUSD   Float    @map("price_monthly_usd")
  priceYearlyUSD    Float    @map("price_yearly_usd")
  storageGB         Float    @map("storage_gb")
  documentsLimit    Int      @map("documents_limit")
  monthlyQueries    Int      @map("monthly_queries")
  apiCallsLimit     Int      @map("api_calls_limit")
  features          Json?
  isActive          Boolean  @default(true) @map("is_active")
  displayOrder      Int      @default(0) @map("display_order")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  subscriptions     Subscription[]

  @@map("subscription_plans")
}

// User Subscriptions - Active user subscriptions
model Subscription {
  id                String   @id @default(uuid())
  userId            String   @map("user_id")
  planId            String   @map("plan_id")
  status            String   @default("pending") // pending, active, suspended, cancelled, expired
  billingCycle      String   @default("monthly") @map("billing_cycle") // monthly, yearly
  currentPeriodStart DateTime @map("current_period_start")
  currentPeriodEnd   DateTime @map("current_period_end")
  cancelAtPeriodEnd  Boolean  @default(false) @map("cancel_at_period_end")
  cancelledAt        DateTime? @map("cancelled_at")
  stripeSubscriptionId String? @unique @map("stripe_subscription_id")
  stripeCustomerId     String? @map("stripe_customer_id")
  paypalSubscriptionId String? @unique @map("paypal_subscription_id")
  metadata          Json?
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan              SubscriptionPlan @relation(fields: [planId], references: [id])
  payments          Payment[]

  @@index([userId])
  @@index([status])
  @@map("subscriptions")
}

// Payments - All payment transactions
model Payment {
  id                String   @id @default(uuid())
  subscriptionId    String?  @map("subscription_id")
  userId            String   @map("user_id")
  amount            Float
  currency          String   @default("USD")
  method            String   // stripe, paypal, bank_transfer, cash_deposit
  status            String   @default("pending") // pending, processing, completed, failed, refunded
  externalId        String?  @map("external_id") // Stripe/PayPal transaction ID
  description       String?
  metadata          Json?
  processingFee     Float?   @map("processing_fee")
  netAmount         Float?   @map("net_amount")
  paidAt            DateTime? @map("paid_at")
  failedAt          DateTime? @map("failed_at")
  refundedAt        DateTime? @map("refunded_at")
  errorMessage      String?  @map("error_message")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  subscription      Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  paymentProof      PaymentProof?

  @@index([userId])
  @@index([status])
  @@index([method])
  @@index([createdAt])
  @@map("payments")
}

// Payment Proofs - Manual payment verification (bank transfers, deposits)
model PaymentProof {
  id                String   @id @default(uuid())
  paymentId         String   @unique @map("payment_id")
  userId            String   @map("user_id")
  fileUrl           String   @map("file_url")
  fileName          String   @map("file_name")
  fileSize          Int      @map("file_size")
  mimeType          String   @map("mime_type")
  bankName          String?  @map("bank_name")
  accountNumber     String?  @map("account_number")
  referenceNumber   String?  @map("reference_number")
  depositDate       DateTime? @map("deposit_date")
  notes             String?  @db.Text
  status            String   @default("pending") // pending, approved, rejected
  reviewedBy        String?  @map("reviewed_by")
  reviewedAt        DateTime? @map("reviewed_at")
  reviewNotes       String?  @map("review_notes") @db.Text
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  payment           Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer          User?    @relation("ReviewedPaymentProofs", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("payment_proofs")
}
